<p align="center">
 <img width="100px" src="https://raw.githubusercontent.com/NekoSilverFox/NekoSilverfox/403ab045b7d9adeaaf8186c451af7243f5d8f46d/icons/silverfox.svg" align="center" alt="NekoSilverfox" />
 <p align="center"><b><font size=6>软件工程</font></b></p>
 <p align="center"><b>优质软件开发过程的基本原理及其计量方法 & 持续更新中...</b></p>
</p>



<div align=center>



<div align=left>
<!-- 顶部至此截止 -->


<!-- SPbSTU  -->

 <p align="center">
  <img width="250px" src="https://github.com/NekoSilverFox/NekoSilverfox/blob/master/icons/logo_building_spbstu.png?raw=true" align="center" alt="ogo_building_spbstu" />
  </br>
  </br>
  <b><b>Санкт-Петербургский государственный политехнический университет</b></br></b>
  <b>Институт компьютерных наук и технологий</b>
 </p>
 <p align="center"></p>

</p>

<div align=left>
<!-- SPbSTU 最后一行 -->


[toc]

> 基于圣彼得堡国立理工大学的讲座



# 软件开发模型

> https://cloud.tencent.com/developer/article/1724043
>
> https://zhuanlan.zhihu.com/p/43885605

模型也称为软件开发生命周期（SDLC）模型/方法。每个过程模型都遵循其类型所独有的一系列阶段，以确保软件开发步骤中的成功。

## 瀑布模型

> 

<img src="https://ask.qcloudimg.com/http-save/7873281/q9sjeyf5ir.png?imageView2/2/w/1620" alt="img" style="zoom:50%;" />

瀑布模型（Waterfall） 是最简单的软件开发历史上第一个 SDLC 模型。在瀑布模型中，开发过程是线性的。任务和阶段按严格顺序一个接一个地完成。进度平稳地向下流动，就像瀑布上的水一样。

瀑布模型的主要缺点是不灵活。瀑布易于理解且易于管理。但是过早的延迟会拖延整个项目的时间表。由于一旦完成阶段，几乎没有修改的余地，因此只有进入维护阶段才能解决问题。如果需要灵活性，或者项目是长期的且正在进行的，则此模型不能很好地工作。

瀑布模型是一种比较老旧的软件开发模型，1970年温斯顿·罗伊斯提出了著名的“瀑布模型”，直到80年代都还是一直被广泛采用的模型。

　　瀑布模型将软件生命周期划分为制定计划、需求分析、软件设计、程序编写、软件测试和运行维护等六个基本活动，并且规定了它们自上而下、相互衔接的固定次序，如同瀑布流水，逐级下落。

　　在瀑布模型中，软件开发的各项活动严格按照线性方式进行，当前活动接受上一项活动的工作结果，实施完成所需的工作内容。当前活动的工作结果需要进行验证，如验证通过，则该结果作为下一项活动的输入，继续进行下一项活动，否则返回修改。

　　瀑布模型优点是严格遵循预先计划的步骤顺序进行，一切按部就班比较严谨。

　　瀑布模型强调文档的作用，并要求每个阶段都要仔细验证。但是，这种模型的线性过程太理想化，已不再适合现代的软件开发模式，几乎被业界抛弃，其主要问题在于：

　　1） 各个阶段的划分完全固定，阶段之间产生大量的文档，极大地增加了工作量；

　　2） 由于开发模型是线性的，用户只有等到整个过程的末期才能见到开发成果，从而增加了开发的风险；

　　3） 早期的错误可能要等到开发后期的测试阶段才能发现，进而带来严重的后果。

　　4） 各个软件生命周期衔接花费时间较长，团队人员交流成本大。

　　5） 瀑布式方法在需求不明并且在项目进行过程中可能变化的情况下基本是不可行的。



## 迭代和增量模型

> https://zh.wikipedia.org/zh-cn/迭代式开发
>
> https://en.wikipedia.org/wiki/Iterative_and_incremental_development

<img src="https://ask.qcloudimg.com/http-save/7873281/n0zapjkim8.png?imageView2/2/w/1620" alt="img" style="zoom:50%;" />

**迭代式开发**也被称作**迭代增量式开发**或**迭代进化式开发**，是一种与传统的[瀑布式开发](https://zh.wikipedia.org/wiki/瀑布式开发)相反的[软件开发方法](https://zh.wikipedia.org/w/index.php?title=软件开发方法&action=edit&redlink=1)，它弥补了传统开发方式中的一些弱点，具有更高的成功率和生产率。

迭代和增量 SDLC 模型将**迭代设计和工作流**与增量构建模型结合在一起。在这种情况下，团队将按周期开发产品，**并以渐进方式构建小零件**。

开发过程从简单实施一组严格限制的小型产品需求开始。然后对该产品进行增强，并使其本身成为更完整的版本，直到完成并准备好进行部署为止。**每次迭代都可能包含设计更新和新功能。**

迭代和增量模型的一个有价值的特点是**可以在不知道所有需求的情况下开始开发**。该模型包含其他 SDLC 模型的步骤-需求收集，设计，实施和测试，但要经过多次构建。开发团队可以利用先前构建中取得的成就来改善下一构建。

迭代和增量 SDLC 模型可能看起来像一组微型瀑布模型或微型 V 形模型。







# 软件开发流程、问题追踪和管理

> Процессы разработки ПО Отслеживание проблем, управление проблемами



## 概述

**问题是什么：**

用户、开发人员、测试人员发现的产品问题（bug），问题是一个正在运行程序的不正常行为





**问题的分类（Проблема становится）：**

- ==failure（сбоем）== 失败，导致程序错误或者不正常的行为
- ==改进型（запросом на улучшение）==，如果是软件产品中的遗漏，则提出改进要求（软件中需求的缺失，没以最佳的方式为用户实现需求，等等）
- ==特性（свойством программы）==，如果是软件的正常行为，那它不是一个错误，而是特性





**问题的声明周期（Жизненный цикл проблемы）：**

在软件产品中发现 bug 的生命周期一般有 5 各阶段：

1. 用户（或者任何对软件有经验的人）将问题**提交（информирует）**给软件制造商
2. 制造商在自己的环境中**重现（воспроизводит）**问题
3. 制造商**隔离（изолирует）**引发问题的条件
4. 制造商**定位和修复（находит и исправляет）**缺陷
5. 制造商**重新发布（передает）**正确版本





**制造商有义务解决一下问题：**

- 如何组织软件生命周期中出现的问题
- 哪些问题是当前**无法修复（нерешенными）**的
- 哪些问题是当前**严重（серьезными）**的
- 此问题在**以前是否出现过（похожиепроблемы）**



## 问题追踪

> Отслеживание проблем





### 问题的报告

> Отчеты о проблемах

为了能够更好的修正错误，开发者应该能够重现它

软件生命明周期中的 bug，应该伴随着**错误报告（отчетом о проблеме）**



**以下属于都代指问题报告：**

- PR (Problem Report)
- CR (Change Request)
- 错误报告 (Bug Report)



**错误报告中应该：**

- **问题的事实（Факты по проблеме）**

    - **问题的描述（Хронология проблемы | Problem History）**，对重现问题的最少步骤的描述、对资源文件的描述（比如，配置文件、输入文件、数据库记录等）

        > **问题的描述（Хронология проблемы | Problem History）:**
        >
        > - 描述重现问题所需的最小步骤集
        >
        > - 被访问资源的描述
        >
        >     *1. 在窗口 A中打开fox.pdf*
        >
        >     *2. 使用默认配置打印时...*
        >
        > - 如果问题无法重现，那么很可能不会被修复

    - **描述观察到的异常行为（Описание наблюдаемого поведения）**

        > **观察到的行为（Observed Behavior | Наблюдаемое поведение программы）：**
        >
        > - 描述问题的症状，即发生了什么事 与预期的行为相反的是
        >
        >     *一个程序崩溃，有以下信息...*
        >
        >     *STACK DUMP of CRASH (yyy OS)*
        >
        > - 在描述中保持中立是很重要的，坚持用事实说话而不是表现出情绪
        >
        > - 对于开发者来说，对观察到的行为的描述是非常重要的，因为它模拟了再现错误的步骤

    - **描述预期行为（Описание ожидаемого поведения）**

        > **预期行为（Expected Behavior | Ожидаемое поведение программы）：**
        >
        > - 从用户的角度描述应该发生的事情*（比如：该软件应该打印该文件）*
        > - 这些信息对开发者来说没有步骤顺序或诊断信息那么重要，但它确实有助于确定用户和开发者对软件产品在所述条件下的行为是否有相同的理解
        > - 审视现实（Проверка на «реальность»），用户的期望是否合理

    - **对问题性质的简短描述（one-line summary | Краткое описание сути）**

        > **对问题性质的简短描述（one-line summary | Краткое описание сути）:**
        >
        > - 发现问题的人必须简要描述问题*（比如：打开PDF文档时ABC崩溃了）*
        > - 通常情况下，问题的性质是决定其**严重性（серьезности）**（对客户的影响）和补救问题的**优先级（приоритете）**的基础

        

- **软件产品的事实**

    - 软件的版本（Номер версии）及具体编号（比如 ：Publishing Program 1.2 (Build 12B34)）

        > **唯一产品标识符（Product Release | Уникальный идентификатор продукта）：**
        >
        > - 表示软件产品的版本号或其他唯一标识符
        > - 需要指定确切的版本（比如：Publishing Program 1.2 (Build 12B34)）
        > - 存档（如果有关于不同软件版本如何工作的信息）这个问题是否只发生在这个版本的软件上，还是在其他版本中也很常见？

    - 软件的运行环境（Версия операционной системы）（比如：Mac OS X 10.5.5 (9F33) ）

        > **运行环境描述（Operating Environment | Описание операционной среды）：**
        >
        > 关于操作系统的信息通常表示为：
        >
        > - 这些信息可以是简短的，也可以是更详细的（“Windows 98 SE” or “Debian Linux ‘Sarge’ with the following packages... ”）
        >
        > 总结：问题发生在哪个环境中？它是否发生在其他操作环境中？(例如，如果产品在一个以上的平台上运行)
        >
        > 

    - 系统资源（Системные ресурсы）（比如：内存容量、磁盘空间、其他硬件资源）





**自动的事实调查（Автоматический сбор фактов）：**

- 许多软件产品包括特殊功能或独立工具，用于生成标准问题报告
    - 通常，这类工具会向供应商发送专有信息*（比如：一个完整的内核转储，存储故障发生时的程序状态）*
    - 用户隐私（Конфиденциальность пользователя）是自动事实调查中的一个大问题
- 用户应该了解你的产品可能**收集和发送（собирать и отправлять）**的任何信息，他们也应该能够**关闭（отключить）**负责收集这些信息的功能



### 问题的管理

> Управление проблемами

- ==方案一：==使用一个带有**问题列表（списком проблем）**的唯一文档，里面记录了关于目前所有**开放或者未解决（открытых или нерешенных）**的问题

    - 易于创建和维护 (+)
    - 一次只能有一个人处理一个文件（-）
    - 以前检测和纠正的问题会丢失（-）
    - 没有可扩展性（不能用一个文本文件来跟踪数百个问题）（-）

    

- ==方案二：==使用数据库来记录问题





### 问题的分类

> Классификация проблем



**对问题进行分类的典型属性（Типичные атрибуты）：**

- **严重程度（Серьёзность | Severity）**

    > **严重程度（Серьёзность | Severity）：**
    >
    > 严重程度决定了一个问题对**开发或产品发布过程的影响程度（процесс разработки или выпуска продукта）**。每个工具都可以有自己的严重程度属性值列表。下面是一个属性值列表的例子：
    >
    > - **增强（Enhancement | Пожелание）** – 希望改善软件的功能或可用性
    > - **琐碎（Trivial | Тривиальная）**- 外观问题，本质上不影响软件产品的功能
    > - **次要（Minor | Незначительная）**– 不需要紧急修复的问题
    > - **一般（Normal | Существенная）**– 这是一个 "常见 "的问题，*（比如：说软件功能的小幅损失）*
    > - **严重（Major | Серьёзная）**– 软件功能的重大损失
    > - **紧急（Critical | Критическая）**– 程序崩溃、数据丢失或严重的内存泄漏
    > - **禁止或阻止（Blocker or Showstopper | Чрезвычайная）**– 持续的系统错误，阻止进一步的开发和/或测试工作

    

- **优先级（Приоритет | Priority）**

    - 每个问题都有一定的**优先级（Приоритет | Priority）**
    - 优先级越高，对问题的反应越快
    - ==**优先性和严重性（Приоритет и Серьёзность）不一定是相关的!!**==
    - 优先级通常由管理层决定
    - **确定优先次序（Установка приоритетов**）—— 控制发展和解决问题的关键工具

    

- **标识符、检验人（Идентификатор | Identifier）**

    - 每个问题都有**唯一标识符（PR-number or CR-number，也称为故障号）**
    - 该标识符或编号通常用于所有内部开发文件--电子邮件、变更日志、进度报告等

    *比如：Subject: RP #1234 is fixed?*

    

- **评论（Комментарии | Comments）**

    - 任何用户和开发者都可以在问题报告上留下评论
    -  评论可以包括文件、文档、关于问题条件的信息、他们对缺陷位置的假设等

    

- **通知（Уведомления | Notification）**

    - 开发人员可以在问题报告中包括他们的电子邮件地址。然后，每当该报告发生变化时，他们将被自动通知
    - 用户也可以利用这一功能





### 问题的处理

> Обработка проблем



**处理问题 - 生命周期（Обработка проблем – жизненный цикл）：**

![image-20220928171122404](doc/pic/README/image-20220928171122404.png)

1. 错误报告被输入问题数据库

2. 错误报告是有效的，并且错误不是与已知的问题重复的；如果不是这样，报告就会转到已解决

3. 该问题被分配给一个开发者（实施者）

    **问题解决（разрешение проблемы）：**

    一个问题报告可以通过几种方式进入解决状态

    - **已解决（Fixed | Исправлена）**
    - **无效（Invalid | Недостоверная）**- 要么问题不是问题，要么报告包含不相关的事实
    - **重复（Duplicate | Дубликат）**- 该问题已经以另一个条目的形式存在于数据库中
    - **无法修复（Wontfix | Не подлежит исправлению）**-  永远不会被修复
    - **无法重现（Worksforme | Не воспроизводится）**- 该问题无法重现

4. 问题报告已处理，代码已纠正

5. 该问题已被修复；该修复已被验证，程序正常运行

6. 一个包含修复程序的新版本已经发布。该问题被认为已经结束

7. 问题又出现了！



---



**问题跟踪管理流程（Процесс управления отслеживанием проблем）：**

为了创建一个有效的问题管理程序，必须回答问题：

1. 如何（谁）创建（输入）问题报告？
2. 谁对问题报告进行分类？
3. 谁来确定优先次序（考虑问题的严重性、发生的可能性、遇到问题的用户数量、潜在危害）？
4. 谁负责解决这个问题？
5. 谁来关闭问题报告？
6. 问题的生命周期是什么？



---



**软件变更控制团队（Группы контроля над внесением изменений в ПО）：**

- 在许多组织中，一个专门的小组**（Software Change Control Board | 软件变更控制委员会）**负责
- 评估问题的影响（Оценку влияния проблемы）
- 分配执行者（Назначение исполнителей）
- 关闭问题报告（Закрытие отчетов о проблемах）



---



**基于问题的需求开发（Разработка на основе требований в виде проблем）：**

- 问题跟踪系统可以在产品创建的早期阶段使用，以存储需求。
- 每个主要的要求都可以分解成几个较小的要求，可以在一个数据库中进行追踪
- 当所有的 "问题-要求 "都被关闭时，产品就准备好了



---



**问题数据库中的重复管理（Управление дубликатами в базе проблем）：**

- 热点问题跟踪系统被大量的问题报告（"垃圾"）所淹没
- 通过以下方式消除重复的内容：
    - 简化错误报告
    - 要求在添加新条目之前搜索数据库中的重复内容
- 摆脱那些只发生过一次或很久以前以及在内部测试中发生的过时的问题



---

## 提交问题的形式

> Требования в виде проблем



## 问题的链接、修复、测试

> Связывание проблем, исправлений, тестов



**链接的问题和解决方法(Связь проблем и исправлений):**

![image-20220928174205928](doc/pic/README/image-20220928174205928.png)



---



**将问题和测试联系起来（Связь проблем и тестов）：**

- 在执行过程中失败的测试应该被记录在问题跟踪系统中吗？
- 最好将测试结果与问题报告分开存储（不同机构对此的处理方式不同）。
- 如果测试是自动化的，并快速执行，那么重新运行这些测试就比在测试期间发生的问题数据库中存储的故障更容易

## 工具

> Инструменты

**问题追踪工具的例子：**

- Bugzilla https://bugzilla/mozilla/org
- phpBugTracker – 一个轻量级的问题跟踪器  (http://phpbt.sourceforge.net)
- Issue-Tracker
- Trac - 可以与版本控制系统集成。简化了对不同版本产品的问题跟踪(http://trac/edgewall.org)
- SourceForge – (http://www.sourceforge.net)
- GForge



## 总结

- 终端用户发现的问题报告被储存在问题数据库中
- 问题报告应包含与再现问题有关的所有信息
- 定义一套用户应提供的标准项目是很有用的
- 一份有效的问题报告应该是
    - 要有良好的结构。
    - 描述一个可重复的活动序列。
    - 提供对问题的简明描述。
    - 尽可能的简单和概括。
    - 要保持中立和实事求是
- 定义一套用户应该提供的标准元素是很有用的
- 一个问题的典型生命周期从 "未确认 "的状态开始
- 该周期以 "关闭 "状态和具体的解决方案结束（例如 "已解决"、"不可重复"）。
- 通常情况下，软件变更控制小组负责确定优先次序并分配实施者

- 使用版本控制来分离补丁和功能开发
- 建立惯例，将问题报告与变更联系起来，反之亦然。
- 一旦创建了测试问题，问题报告将不再有意义







# CMMI

## 通用目标与通用实践以及过程域（CMMI1.3 第二部分）

> https://blog.51cto.com/mk6yeung/582121
>
> https://zhuanlan.zhihu.com/p/390023672

CMMI全称是Capability Maturity Model Integration，即能力成熟度模型集成。

CMMI是世界公认的软件产品进入国际市场的通行证，不仅是对产品质量的认证，更是一种软件过程改善的途径。如果一家公司最终通过CMMI的评估认证，标志着该**公司在质量管理的能力**已经上升到一个新的高度。

CMMI主要关注点就是成本效益、明确重点、过程集中和灵活性四个方面。



CMMI的价值
CMMI为企业带来价值主要体现在以下几个方面：

1） 对开发流程进行标准化和规范化，保证项目进度和质量。

2） 有利于成本控制，缩减不必要的项目开支。

3） 建立完备的知识库，不畏惧人才流失。

4） 持续改善流程，提高质量和效率。

5） 在一些投标项目竞争中，更具有优势。——这也是一般外包公司特别重视这个证的原因。

6） 来自美国制定的国际标准，更能得到国外的认可。——所以一般软件公司要准备融资上市前都力争拿到此证的原因。



## CMMI 的结构

### 连续式

连续式表述（Continuous）

连续式表述可以提供最大的弹性，一个组织可以**选择改善单一流程相关的问题点的绩效**，或是可以使用多个领域以密切配合组织的经营目标。连续式表述允许对不同的流程执行不同等级的改善。但组织在选择上仍有一些限制，因为有一些流程领域是彼此相依赖的。



### 阶段式

阶段式表达（Staged）

阶段式表达提供系统化结构化的方式，一次一个阶段达到以模型为基础的流程改善。达到每一个阶段可确保有足够的流程基础建设，可作为下一个阶段流程改善的基础。





| 缩写    | 描述                         |
| ------- | ---------------------------- |
| GG 1    | 已执行的过程                 |
| GG 1.1  | 执行特定实践                 |
|         |                              |
| GG 2    | 已管理（执行）的过程         |
| GP 2.1  | 建立组织级方针               |
| GP 2.2  | 计划过程                     |
| GP 2.3  | 提供资源                     |
| GP 2.4  | 分派职责                     |
| GP 2.5  | 培训人员                     |
| GP 2.6  | 控制工作产品                 |
| GP 2.7  | 识别相关干系人，并使之参与   |
| GP 2.8  | 监督并控制过程               |
| GP 2.9  | 客观评价遵守程度             |
| GP 2.10 | 与上级管理层一起进行状态评审 |
|         |                              |
| GG 3    | 已定义的过程                 |
|         |                              |
|         |                              |
|         |                              |
|         |                              |





























